{"pageContext":{"group":[{"node":{"id":"5724ad55-d07b-52af-8795-9f33f00d1edd","html":"<pre><code class=\"language-java\">package com.siro.tools;\n\nimport java.security.*;\n\nimport javax.crypto.*;\n\npublic class DESPlus {\n\n    public static String encrypt(String strKey, String strIn) throws Exception {\n        Security.addProvider(new com.sun.crypto.provider.SunJCE());\n        Key key = getKey(strKey);\n\n        Cipher encryptCipher = Cipher.getInstance(\"DES\");\n        encryptCipher.init(Cipher.ENCRYPT_MODE, key);\n\n        return byteArr2HexStr(encryptCipher.doFinal((strIn.getBytes())));\n    }\n\n    public static String decrypt(String strKey, String strIn) throws Exception {\n        Security.addProvider(new com.sun.crypto.provider.SunJCE());\n        Key key = getKey(strKey);\n\n        Cipher decryptCipher = Cipher.getInstance(\"DES\");\n        decryptCipher.init(Cipher.DECRYPT_MODE, key);\n        return new String(decryptCipher.doFinal((hexStr2ByteArr(strIn))));\n    }\n\n    private static Key getKey(String strKey) throws Exception {\n\n        byte[] arrBTmp = strKey.getBytes();    //获取字节流\n        byte[] arrB = new byte[8];             //创建一个空的8位字节数组（默认值为0）\n\n        //将原始字节数组转换为8位\n        for(int i = 0; i &#x3C; arrBTmp.length &#x26;&#x26; i &#x3C; arrB.length; i++) {\n            arrB[i] = arrBTmp[i];\n        }\n\n        // 生成密钥\n        Key key = new javax.crypto.spec.SecretKeySpec(arrB, \"DES\");\n\n        return key;\n    }\n\n    private static String byteArr2HexStr(byte[] arrB) throws Exception {\n        int iLen = arrB.length;\n        // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍\n        StringBuffer sb = new StringBuffer(iLen * 2);\n        for (int i = 0; i &#x3C; iLen; i++) {\n            int intTmp = arrB[i];\n            // 把负数转换为正数\n            while (intTmp &#x3C; 0) {\n                intTmp = intTmp + 256;\n            }\n            // 小于0F的数需要在前面补0\n            if (intTmp &#x3C; 16) {\n                sb.append(\"0\");\n            }\n            sb.append(Integer.toString(intTmp, 16));\n        }\n        return sb.toString();\n    }\n\n    private static byte[] hexStr2ByteArr(String strIn) throws Exception {\n        byte[] arrB = strIn.getBytes();\n        int iLen = arrB.length;\n\n        // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2\n        byte[] arrOut = new byte[iLen / 2];\n        for (int i = 0; i &#x3C; iLen; i = i + 2) {\n            String strTmp = new String(arrB, i, 2);\n            arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16);\n        }\n        return arrOut;\n    }\n\n    public static void main(String[] args) {\n        try {\n            String Code = \"中B123\";\n            String key = \"1q2w3e4r\";\n            String codE;\n\n            codE = DESPlus.encrypt(key, Code);\n\n            System.out.println(\"加密前的字串：\" + Code);\n            System.out.println(\"加密所用密钥：\" + key);\n            System.out.println(\"加密后的字串：\" + codE);\n            System.out.println(\"解密后的字串：\" + DESPlus.decrypt(key, codE));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<hr>","frontmatter":{"path":"/BfCTBXK4ZqYFkms98iQBh8n6","title":"JAVA DES 加密算法","date":"2011-07-29 09:45:47 +0800","comments":true,"author":"Sir0xb","tags":["java","des"]},"excerpt":""}},{"node":{"id":"7d1269fa-47a4-5fdf-92d8-fb34f9582074","html":"<h5>1.首先把远程机子的信息输入准确，但不要连接。</h5>\n<h5>2.点开选项，进入本地资源选项。</h5>\n<h5>3.点进详细设计里，在驱动器中选择本地盘符。</h5>\n<h5>4.选好之后连接远程主机。</h5>\n<h5>5.在远程主机的我的电脑中可看到本地盘符。</h5>\n<hr>","frontmatter":{"path":"Sir0xb","title":"远程桌面连接，怎么传输文件","date":"2011-07-10 15:07:33 +0800","comments":true,"author":"Sir0xb","tags":["windows"]},"excerpt":"1.首先把远程机子的信息输入准确，但不要连接。 2.点开选项，进入本地资源选项。 3.点进详细设计里，在驱动器中选择本地盘符。 4.选好之后连接远程主机。 5.在远程主机的我的电脑中可看到本地盘符。"}},{"node":{"id":"b18d84a4-a177-5019-81fb-f295b06046f1","html":"<p>1.打开要重新发送的邮件。打开的意思就是双击在新窗口中显示。</p>\n<p>2.在菜单中的“其他动作”下拉，选择“重新发送该邮件”。</p>\n<p>3.会提示“您似乎不是该邮件的原始发送人，是否要重发？”</p>\n<p>是同一帐号就应该没有问题。</p>\n<hr>","frontmatter":{"path":"/XCa8qdNoh2N6NTqAhL2kKycd","title":"Outlook2007 重新发送邮件","date":"2011-06-28 09:02:53 +0800","comments":true,"author":"Sir0xb","tags":["outlook"]},"excerpt":"1.打开要重新发送的邮件。打开的意思就是双击在新窗口中显示。 2.在菜单中的“其他动作”下拉，选择“重新发送该邮件”。 3.会提示“您似乎不是该邮件的原始发送人，是否要重发？” 是同一帐号就应该没有问题。"}},{"node":{"id":"4a23e4ff-34dc-5aba-827e-ec53da21a8a3","html":"<h3>1.中文乱码问题。</h3>\n<h5># 产生乱码的原因分析。</h5>\n<p>创建图表的时候，会调用 ChartFactory 工厂类，工厂类里的创建函数的内部，会创建 JFreeChart 对象，如下：</p>\n<pre><code class=\"language-java\">JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT, plot, legend);\n</code></pre>\n<!--more-->\n<p>其中有个参数是JFreeChart.DEFAULT<em>TITLE</em>FONT，跟进之后会发现其实就是 SansSerif 字体，如下：</p>\n<pre><code class=\"language-java\">public static final Font DEFAULT_TITLE_FONT = new Font(\"SansSerif\", 1, 18);\n</code></pre>\n<p>很多文章说到，用 SansSerif 字体就会产生乱码。真的是这样吗？\n用 jfreechart-1.0.13.jar 会产生乱码，但用 jfreechart-1.0.10.jar 就不会。\n对比两个 jar 包中的 JFreeChart 类，发现 draw 函数进行了更新。\n结论：根本原因不是 SansSerif 字体，而是\nJFreeChart 的作者对默认字体的处理方式发生了变化。</p>\n<h2> </h2>\n<h3>2.TimeSeriesChart    X坐标轴显示问题。包括显示的单位和现实的格式。</h3>\n<h5># 产生此问题的原因是，程序员对 API 的不了解造成的，很过功能在开发 API 的时候已经考虑进去了。</h5>\n<h2> </h2>\n<h3>3.LineChart 底部乱码问题。</h3>\n<h5># Winux 将 JFreeChart 做成了 Servlet 。</h5>\n<p>Servlet 从 URL 中获得参数之后，并没有转码，直接提交到了，JFreeChart 数据构建函数。\n用如下方法转码之后，问题成功解决。</p>\n<pre><code class=\"language-java\">new String(str.getBytes(\"iso-8859-1\"))\n</code></pre>\n<h2> </h2>\n<h4>目前已解决 1 和 2，3正在研究。</h4>\n<p>解决方案如下：</p>\n<pre><code class=\"language-java\">package com.winux.GetChart;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.text.SimpleDateFormat;\n\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.axis.*;\nimport org.jfree.chart.plot.*;\n\npublic class NewJFreeChart {\n    //轴字体\n    static Font font = new Font(\"宋体\", Font.PLAIN, 16);\n    //标题字体\n    static Font titleFont = new Font(\"隶书\", Font.BOLD, 25);\n\n    //设置标题和底部字体\n    private static void setTitleAndLegend(JFreeChart chart){\n        chart.getTitle().setFont(titleFont);\n        chart.getLegend().setItemFont(font);\n    }\n\n    // 设置柱状图坐标轴字体\n    public static void setBarChartLabelFont(JFreeChart chart) {\n        setTitleAndLegend(chart);\n\n        //X轴字体 &#x26;amp; 颜色 &#x26;amp; 倾斜\n        chart.getCategoryPlot().getDomainAxis().setLabelFont(font);\n        chart.getCategoryPlot().getDomainAxis().setTickLabelFont(font);\n        chart.getCategoryPlot().getDomainAxis().setTickLabelPaint(Color.BLUE);\n        chart.getCategoryPlot().getDomainAxis().setCategoryLabelPosition s(CategoryLabelPositions.UP_45);\n\n        //Y轴字体 &#x26;amp; 颜色\n        chart.getCategoryPlot().getRangeAxis().setLabelFont(font);\n        chart.getCategoryPlot().getRangeAxis().setTickLabelFont(font);\n        chart.getCategoryPlot().getRangeAxis().setTickLabelPaint(Color.BLUE);\n    }\n\n    // 设置饼状图坐标轴字体\n    public static void setPieChartLabelFont(JFreeChart chart) {\n        setTitleAndLegend(chart);\n\n        //饼图字体\n        ((PiePlot) chart.getPlot()).setLabelFont(font);\n    }\n\n    // 设置时序图坐标轴字体            ---  第二个参数是例如“YYYY”的字符串\n    public static void setTimeSeriesChartLabelF ont(JFreeChart chart, String DateFormat) {\n        setTitleAndLegend(chart);\n\n        //日期显示格式\n        DateAxis dateaxis = (DateAxis) ((XYPlot) chart.getPlot()).getDomainAxis();\n        dateaxis.setDateFormatOverride(new SimpleDateFormat(DateFormat));\n        //设置坐标间隔。DateTickUnitType.YEAR 是单位，后面 1 是间隔。\n        dateaxis.setTickUnit(new DateTickUnit(DateTickUnitType.YEAR, 1));\n\n        //X轴字体 &#x26;amp; 颜色\n        ((XYPlot) chart.getPlot()).getDomainAxis().setLabelFont(font);\n        ((XYPlot) chart.getPlot()).getDomainAxis().setTickLabelFont(font);\n        ((XYPlot) chart.getPlot()).getDomainAxis().setTickLabelPaint(Color.BLUE);\n\n        //Y轴字体 &#x26;amp; 颜色\n        ((XYPlot) chart.getPlot()).getRangeAxis().setLabelFont(font);\n        ((XYPlot) chart.getPlot()).getRangeAxis().setTickLabelFont(font);\n        ((XYPlot) chart.getPlot()).getRangeAxis().setTickLabelPaint(Color.BLUE);\n    }\n\n    // 设置线图图坐标轴字体\n    public static void setLineChartLabelFont(JFreeChart chart) {\n        setTitleAndLegend(chart);\n\n        //X轴字体 &#x26;amp; 颜色 &#x26;amp; 倾斜\n        chart.getCategoryPlot().getDomainAxis().setTickLabelFont(font);\n        chart.getCategoryPlot().getDomainAxis().setLabelFont(font);\n        chart.getCategoryPlot().getDomainAxis().setTickLabelPaint(Color.BLUE);\n        chart.getCategoryPlot().getDomainAxis().setCategoryLabelPosition s(CategoryLabelPositions.UP_45);\n\n        //Y轴字体 &#x26;amp; 颜色\n        ((NumberAxis) chart.getCategoryPlot().getRangeAxis()).setTickLabelFont(font);\n        ((NumberAxis) chart.getCategoryPlot().getRangeAxis()).setLabelFont(font);\n        ((NumberAxis) chart.getCategoryPlot().getRangeAxis()).setTickLabelPaint(Color.BLUE);\n    }\n}\n</code></pre>\n<hr>","frontmatter":{"path":"/nz0JfJ4s6nQaGlWueyCki7NO","title":"JFreeChart 各种问题","date":"2011-04-16 13:00:11 +0800","comments":true,"author":"Sir0xb","tags":["java","jfreechart"]},"excerpt":"1.中文乱码问题。 # 产生乱码的原因分析。 创建图表的时候，会调用 ChartFactory 工厂类，工厂类里的创建函数的内部，会创建 JFreeChart 对象，如下： 其中有个参数是JFreeChart.DEFAULT TITLE FONT…"}},{"node":{"id":"93ac6946-5a46-59e3-94da-6475dfb3dd82","html":"<h4>log4j.properties配置如下：</h4>\n<pre><code class=\"language-xml\">log4j.rootLogger = debug,CONSOLE\nlog4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender\nlog4j.appender.Threshold = debug\nlog4j.appender.CONSOLE.Target = System.out\nlog4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern =&#x26;gt;&#x26;gt; %p &#x26;lt;&#x26;gt; %d{yyyy-MM-dd HH\\:mm\\:ss}%n&#x26;gt;&#x26;gt; %m%n%n\n</code></pre>\n<p>其中显示级别一定要选择 debug，因为在静态实现的时候也会设定。</p>\n<!--more-->\n<h4>静态log4j实现代码如下：</h4>\n<pre><code class=\"language-java\">package com.winux;\n\nimport org.apache.log4j.Logger;\n\npublic class logs {\n    private static Logger logger = Logger.getLogger(logs.class);\n    private static final String thisClassName = logs.class.getName();\n    //信息分隔符\n    private static final String msgSplit = \":\";\n    //是否要定位服务\n    private static boolean showLocSrc = true;\n    //是否显示日志\n    private static final boolean enabled = true;\n    //显示等级\n    private static int level = 1;\n    private static final int debug = 1;\n    private static final int info = 2;\n    private static final int warn = 3;\n    private static final int error = 4;\n\n    public static final void debug(Object message) {\n        if (!enabled || debug &#x26;lt; level)\n            return;\n        if (showLocSrc) {\n            log(debug, message, Thread.currentThread().getStackTrace());\n        } else {\n            log(debug, message, null);\n        }\n    }\n\n    public static final void info(Object message) {\n        if (!enabled || info &#x26;lt; level)\n            return;\n        if (showLocSrc) {\n            log(info, message, Thread.currentThread().getStackTrace());\n        } else {\n            log(info, message, null);\n        }\n    }\n\n    public static final void warn(Object message) {\n        if (!enabled || warn &#x26;lt; level)\n            return;\n        if (showLocSrc) {\n            log(warn, message, Thread.currentThread().getStackTrace());\n        } else {\n            log(warn, message, null);\n        }\n    }\n\n    public static final void error(Object message) {\n        if (!enabled || error &#x26;lt; level)\n            return;\n        if (showLocSrc) {\n            log(error, message, Thread.currentThread().getStackTrace());\n        } else {\n            log(error, message, null);\n        }\n    }\n\n    private static String getStackMsg(StackTraceElement[] ste) {\n        if (ste == null)\n            return null;\n\n        boolean srcFlag = false;\n        for (int i = 0; i &#x26;lt; ste.length; i++) {\n            StackTraceElement s = ste[i];\n\n            // 如果上一行堆栈代码是本类的堆栈，则该行代码则为源代码的最原始堆栈。\n            if (srcFlag) {\n                return s == null ? \"\" : s.toString();\n            }\n\n            // 定位本类的堆栈\n            if (thisClassName.equals(s.getClassName())) {\n                srcFlag = true;\n            }\n        }\n        return null;\n    }\n\n    private static void log(int level, Object message, StackTraceElement[] ste) {\n        if (ste != null) {\n            message = getStackMsg(ste) + msgSplit + message;\n        }\n\n        switch (level) {\n        case info:\n            logger.info(message);\n            break;\n        case debug:\n            logger.debug(message);\n            break;\n        case warn:\n            logger.warn(message);\n            break;\n        case error:\n            logger.error(message);\n            break;\n        default:\n            logger.debug(message);\n        }\n    }\n\n    public static void main(String[] args) {\n        logs.debug(\"测试输出\");\n        logs.info(\"测试输出\");\n    }\n}\n</code></pre>\n<hr>","frontmatter":{"path":"/NWmM10nSXfwe2snC1E6M8o9J","title":"Log4j静态使用","date":"2011-04-16 12:58:33 +0800","comments":true,"author":"Sir0xb","tags":["java","log4j"]},"excerpt":"log4j.properties配置如下： 其中显示级别一定要选择 debug，因为在静态实现的时候也会设定。 静态log4j实现代码如下："}}],"pathPrefix":"blog","first":false,"last":true,"index":15,"pageCount":15,"additionalContext":{}}}