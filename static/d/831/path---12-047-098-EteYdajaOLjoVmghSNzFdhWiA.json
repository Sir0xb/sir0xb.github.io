{"pageContext":{"group":[{"node":{"id":"b99e675f-00bc-54f2-b0b8-b82e645e520f","html":"<p>经常弄不清自己是谁；放历史情境里，更不知道自己会是谁。</p>\n<p>多年前的一天，我列举了中国历史上一大堆文学家、艺术家、科学家、教育家、政治家等著名人物，然后问学生们：你最崇拜其中哪一位？</p>\n<p>被选择最多的群体是政治家，政治家中被选择最多的是可想而知那几位，可想而知那几位里被选择最多的是成吉思汗。</p>\n<p>理由是，当时国家最强，打的最远，疆域最大，一代天骄，举世无双，“有威名、有魄力、有智慧、异常英勇……”</p>\n<!--more-->\n<p>接着，我问了这样一个问题：如果恰好活在他那个时代，想一想，你会是谁？</p>\n<p>问题显然有点出乎意料，众人一时摸不着头脑。</p>\n<p>好吧，我来帮你们设想一下。</p>\n<p>首先成吉思汗就一个，成为他的可能性几乎没有。退而求其次，宗室诸王、万户官、千户官，一共分封还不到百人。</p>\n<p>你不怕流血厮杀，想象当个勇猛的骑士也不错，这也一共才几十万。</p>\n<p>就是整个蒙古民族，当时不过百多万，在中国版图内各民族人口中属于很少一部分，就整个欧亚大陆来说更是如此。</p>\n<p>成吉思汗曾说，男子最大之乐事，在于压服乱众，战胜敌人，夺取其所有的一切，骑其骏马，纳其美貌之妻妾。历史记载，蒙古铁蹄所到之处，屠城无数，哀鸿遍野，文明摧毁，满目疮痍。</p>\n<p>而你，从概率上看，最有可能是家产遭掠，亲人被夺，沦为奴役，甚至死于非命的被征服民族中一员。</p>\n<p>就算你熬过了战乱，别忘了蒙古统治者还把人分为四等：蒙古人；色目人，即中西亚人；汉人；南人，也就是南宋人。后两种人按规定被打不能还手，十户一把菜刀，结婚蒙古人有初夜权，人老直接送坟墓等死，不准集会、不准拜神、不准打猎、不准买卖……你觉得你更可能是哪一等？</p>\n<p>就算你幸为蒙古人，那又如何？蒙古人也要提供大量赋役，遇到征伐，还要自备马匹、兵械、衣食出征，为筹备这些有人甚至要出卖妻儿。出征一次多少年，常常一去不复还……</p>\n<p>说到此，我停下望着他们，底下一片沉默。</p>\n<p>现在，社会变迁，思维多元，但弄不清自己是谁这种症状并未明显减少，依然经常有所表现。</p>\n<p>那年，美国发生911恐怖袭击，竟有那么多人欢呼喝彩。国际上每每发生恐怖袭击事件，尤其针对西方国家，都不乏叫好之声。恐怖主义本来是无规则、无底线、无差别的反人类，是世界公敌，好多人却当成了反对霸权的英雄。后来，塔利班组织在巴基斯坦一个高山上，杀害了多名登山者，其中包括两名中国人，有些人才惊异的意识到，恐怖分子原来也杀中国人。你以为你是谁？</p>\n<p>有次国庆节在家看电视，又见圆明园里一女游客在镜头前谈爱国，说看了遗址心里特别不舒服，侵略者把我们这么美好家园给破坏，现在他们不敢了，我们人民也不允许这样。一时间声泪俱下。</p>\n<p>且不说那场战争的发生清朝有多大责任，更不为事实俱在的抢劫辩护，我只想小声提醒一下这位女士，如果您不姓爱新觉罗，就请注意点产权问题。那圆明园是皇帝的私家园林，好像没您什么事儿，别我们我们的，那时候就算没烧，能让您进去？就是现在，您也是买了门票的吧。</p>\n<p>最近，又时常听到有人怀念、赞颂那个“火红年代”。先看看下边这些，你觉得你那个时候会是谁：“造反有理”的学生；“广阔天地练红心”的知青；遭遇“自然灾害”的农民；“停产闹革命”的工人；“知识越多越反动”的知识分子；“地富反坏右”或他们的子女；被打倒的“走资派”；被揪斗的“牛鬼蛇神”；死得不明不白的将军、元帅、国家主席……</p>\n<p>你对伟大领袖“与人斗其乐无穷”、“为有牺牲多壮志，敢叫日月换新天”的豪迈敬佩得五体投地，你怎么知道被斗的不是你，牺牲的不是你？核战争有什么了不起，中国6亿人，死一半还剩3亿，你怎么知道你不是死的那一半？</p>\n<p>当你为一种力量的崛起而赞叹，乃至热血沸腾的时候；当你为一种力量的覆灭而悲情，感到愤怒屈辱的时候；当你为一种力量的肆虐而欢呼，感觉事不关己，幸灾乐祸的时候，最好先想一想这个问题：</p>\n<p>你，以为你是谁；你，以为你会是谁？</p>\n<hr>","frontmatter":{"path":"/ElJlqXhZ6Euieu8DN6SDgZ4g","title":"你以为你是谁——致那些吃沟油操海心的人","date":"2016-08-12 12:14:10 +0800","comments":true,"author":"孙立平","tags":["思考"]},"excerpt":"…"}},{"node":{"id":"83a36fbe-3ebd-516c-b73e-d40a9d31933d","html":"<p>我们常说，中国人喜欢撒谎，做事不讲规则，没有契约精神。虽然我无法知道中国人是从什么时候开始有这些毛病，但能成为一个民族共性的现象，一定有着深刻的文化内涵。有一点我敢断言，“田忌赛马”的智慧对我们民族的这些国民性的影响是极大的，贻害也是深远的。</p>\n<p>田忌经常与齐国诸公子赛马，设重金赌注。孙膑发现他们的马脚力都差不多，可分为上、中、下三等。于是孙膑对田忌说：“您只管下大赌注，我能让您取胜。”田忌相信并答应了他，与齐王和诸公子用千金来赌胜。</p>\n<!--more-->\n<p>比赛即将开始，孙膑说：“现在用您的下等马对付他们的上等马，拿您的上等马对付他们的中等马，拿您的中等马对付他们的下等马。”三场比赛完后，田忌一场不胜而两场胜，最终赢得齐威王的千金赌注。</p>\n<p>其实，只要一点破，再读这个故事就很容易发现，田忌（孙膑）就是胜在作假、破坏规则和契约上——用下等马假充上等马、上等马假充中等马、中等马假充下等马于齐威王比赛，是“为达目的不择手段”的。</p>\n<p>可能有人会说，赛前没有定规则呀？其实，我们只要认真看看故事，就会明白，里面的规则规定的是很明确的：“齐国的大将田忌，很喜欢赛马，有一回，他和齐威王约定，要进行一场比赛。他们商量好，把各自的马分成上，中，下三等。比赛的时候，要上马对上马，中马对中马，下马对下马。由于齐威王每个等级的马都比田忌的马强得多，所以比赛了几次，田忌都失败了。……”其中所述的非常明确——约定了上马对上马、中马对中马、下马对下马进行比赛的规则，因此，田忌（孙膑）违规、违约是显而易见的。</p>\n<p>这个故事就这样传颂千古，大家都很以为然，并没有觉得有什么不妥，甚至说：这个故事表现了“孙膑细致的观察能力和运筹能力”，揭示了“如何善用自己的长处去对付对手的短处，从而在竞技中获胜”……</p>\n<p>这说明中国人普遍缺乏规则和契约意识以及对作假行为的认同，也说明我们这个民族整体是不知善恶和无耻的。也许，这也是我们民族始终无法走出蒙昧，走进文明的原因</p>\n<p>也许有人会说，虽然有些无耻，但你不能否认其聪明。这样说，只能证明我们民族确是弱智的，因为我们只能看到破坏规则和契约带来的好处，无法理解遵守规则和契约带来的巨大好处。</p>\n<p>当然，破坏规则对于少数人来说有时是高效的，但对于整体来说却是低效的，甚至是代价高昂的。比如说，在我国的很多城市都会经常发生堵车，有时一堵就是几十分钟甚至几个小时，但前年我在韩国的首尔，看到远比我们多的车辆，但人家那里几乎不堵车，在首都的大街上，车可以开到80码。人家的守规则意识太强了。我们乘坐的大巴，走匝道右转弯，直行车辆没过完之前，司机是绝对不抢道的。正因为人家人人守规则，所以人人都不当误事儿；正因为我们很多人破坏规则，抢道加塞，结果是车走的像蜗牛爬，人人受害。</p>\n<p>田忌赛马，耍的是小聪明，而一个对小聪明大加赞赏的民族，我实在是看不出他的聪明来！</p>\n<hr>","frontmatter":{"path":"/eFX5dhu5Ur2OgJIFBzQIuGos","title":"“田忌赛马”对后世的毒害之深超乎你的想象","date":"2016-08-12 11:55:40 +0800","comments":true,"author":"Sir0xb","tags":["田忌赛马","思考"]},"excerpt":"…"}},{"node":{"id":"d883ac12-5a98-51fd-b496-0ae482800847","html":"<blockquote>\n<p>为了演示流控制，简单实现了注入插件 gulp-aop</p>\n</blockquote>\n<h3>先看下 gulp-aop 注入插件的用法</h3>\n<pre><code class=\"language-coffeescript\">gulp = require \"gulp\"\nconcat = require \"gulp-concat\"\naop = require \"gulp-aop\"\n\ngulp.task \"default\", ->\n    gulp.src [\"test/a.js\", \"test/b.js\"]\n    .pipe concat \"t.min.js\"\n    .pipe aop\n        header: -> console.log 'Inject to the head'\n        footer: -> console.log 'Inject to the end'\n    .pipe gulp.dest \"./test\"\n</code></pre>\n<!--more-->\n<p>了解 gulp 流控制之前先了解下 nodeJS 的流</p>\n<h2> </h2>\n<h3>nodeJS 四种流</h3>\n<p>nodeJS里有四种类型的流：Readable，Writable，Duplex，Transform</p>\n<p>Readable: 可读流</p>\n<p>Writable: 可写流</p>\n<p>Duplex: 双工流</p>\n<p>Transform: 转换流</p>\n<p>跟 Gulp 相关的主要是转换流</p>\n<blockquote>\n<p>gulp 流控制一般用如下两种方式</p>\n</blockquote>\n<h2> </h2>\n<h3>流截获方式一：</h3>\n<pre><code class=\"language-javascript\">var through = require('through-gulp');\n\nmodule.exports = function () {\n    var stream = through(function(file, encoding, callback) {\n        var sourceStr = file.contents.toString();\n\n        // 这里可以对代码进行处理\n\n        file.contents = new Buffer(sourceStr);\n\n        // 再往管道中注入修改后的内容\n        this.push(file);\n\n        callback();\n    });\n\n    stream.on(\"end\", function () {\n        // 这里可以做些收尾工作\n    });\n\n    return stream;\n};\n</code></pre>\n<h2> </h2>\n<h3>流截获方式二：</h3>\n<pre><code class=\"language-javascript\">var through = require('through2');\nvar fs = require(\"fs\");\n\nmodule.exports = function (opt) {\n    var aopHeader = \"(\" + (opt.header || function(){}).toString() + \"());\";\n    var aopFooter = \"(\" + (opt.footer || function(){}).toString() + \"());\";\n\n    function bufferContents(file, encoding, callback) {\n        if (file.isNull()) {\n            this.push(file);\n            return callback();\n        }\n\n        if (file.isStream()) {\n            this.push(file);\n            return callback();\n        }\n\n        if (file.isBuffer()) {\n            file.contents = new Buffer(aopHeader + file.contents.toString('utf8') + aopFooter);\n        }\n\n        this.push(file);\n\n        callback();\n    }\n\n    function endStream(callback) {\n        // 这里可以做些收尾工作\n        callback();\n    }\n\n    return through.obj(bufferContents, endStream);\n};\n</code></pre>\n<blockquote>\n<p>编写自己的 Gulp 插件，流控制是基础。</p>\n</blockquote>\n<hr>","frontmatter":{"path":"/m5EMxLkw8rhWmyW1AEQWOQ7u","title":"Gulp流控制","date":"2016-01-31 23:38:00 +0800","comments":true,"author":"Sir0xb","tags":["coffee","gulp"]},"excerpt":"为了演示流控制，简单实现了注入插件 gulp-aop 先看下 gulp-aop 注入插件的用法 了解 gulp 流控制之前先了解下 nodeJS 的流   nodeJS 四种流 nodeJS里有四种类型的流：Readable，Writable，Duplex，Transform…"}},{"node":{"id":"6529f711-9320-5845-a3b6-43d4172b8cd9","html":"<h3>类的定义：</h3>\n<pre><code class=\"language-javascript\">var Clazz = (function () {\n    var Clazz = function () { },\n        initializing = false\n        superPattern = /xyz/.test(function() { xyz; }) ? /\\b_super\\b/ : /.*/;\n\n    Clazz.create = function (properties) {\n        var _super = this.prototype;\n        initializing = true;\n        var proto = new this();\n        initializing = false;\n\n        for (var name in properties) {\n            proto[name] = typeof properties[name] == \"function\" &#x26;&#x26;\n            typeof _super[name] == \"function\" &#x26;&#x26; superPattern.test(properties[name]) ?\n                (function(name, fn) {\n                    return function() {\n                        var tmp     = this._super;\n                        this._super = _super[name];\n                        var ret     = fn.apply(this, arguments);\n                        this._super = tmp;\n                        return ret;\n                    };\n                })(name, properties[name]) : properties[name];\n        }\n\n        function _Clazz() {\n            if (!initializing &#x26;&#x26; this.init) {\n                this.init.apply(this, arguments);\n            }\n        }\n\n        _Clazz.prototype     = proto;\n        _Clazz.constructor   = Clazz;\n        _Clazz.create        = arguments.callee;\n\n        return _Clazz;\n    }\n\n    return Clazz;\n}());\n</code></pre>\n<!--more-->\n<h2> </h2>\n<h3>类的使用：</h3>\n<pre><code class=\"language-javascript\">var Person = Clazz.create({\n    init: function (isDancing) {\n        this.dancing = isDancing;\n    },\n    dance: function () {\n        return this.dancing;\n    }\n});\n\nvar Child = Person.create({\n    init: function () {\n        this._super(false);\n    },\n    dance: function () {\n        return this._super();\n    },\n    swiming: function () {\n        return true;\n    }\n});\n\nvar person = new Person(true);\nvar child = new Child();\n\nconsole.log('家长能跳舞.');\nconsole.log(person.dance());\n\nconsole.log('孩子能游泳');\nconsole.log(child.swiming());\n\nconsole.log('孩子不会跳舞.');\nconsole.log(child.dance());\n\nconsole.log('家长是人类.');\nconsole.log(person instanceof Person);\n\nconsole.log('孩子也是人类.');\nconsole.log(child instanceof Child &#x26;&#x26; child instanceof Person);\n</code></pre>\n<hr>","frontmatter":{"path":"/ZFR4s3OTFvgwRvL50hiVwpY5","title":"JavaScript实现类效果","date":"2016-01-27 11:00:00 +0800","comments":true,"author":"Sir0xb","tags":["javascript"]},"excerpt":"类的定义：   类的使用："}},{"node":{"id":"38fa7528-73f5-544e-95e1-4ebad7e3a1c5","html":"<h3>js 压缩合并</h3>\n<pre><code class=\"language-coffeescript\">gulp = require \"gulp\"\njshint = require \"gulp-jshint\"\nconcat = require \"gulp-concat\"\nuglify = require \"gulp-uglify\"\n\ngulp.task \"script\", ->\n    gulp.src [\"xxx\", \"yyy\"]\n    .pipe jshint()\n    .pipe concat \"base.min.js\"\n    .pipe uglify()   # 混淆\n    .pipe gulp.dest \"输出目录\"\n</code></pre>\n<!--more-->\n<h2> </h2>\n<h3>js 压缩不合并</h3>\n<pre><code class=\"language-coffeescript\">gulp = require \"gulp\"\njshint = require \"gulp-jshint\"\nrename = require \"gulp-rename\"\nuglify = require \"gulp-uglify\"\nsourcemaps = require \"gulp-sourcemaps\"\n\ngulp.task \"script\", ->\n    gulp.src [\"xxx.js\", \"!xxx.min.js\", \"yyy.js\", \"!yyy.min.js\"]\n    .pipe sourcemaps.init()\n    .pipe jshint()\n    .pipe rename\n        extname: \".min.js\"\n    .pipe uglify\n        mangle: no  # 不混淆\n    .pipe sourcemaps.write \"./\"\n    .pipe gulp.dest \"./\"\n</code></pre>\n<h2> </h2>\n<h3>js 压缩加版本号</h3>\n<pre><code class=\"language-coffeescript\">path = require \"path\"\ngulp = require \"gulp\"\nplumber = require \"gulp-plumber\"\njshint = require \"gulp-jshint\"\nrename = require \"gulp-rename\"\nuglify = require \"gulp-uglify\"\nrev = require \"gulp-rev\"\n\ngulp.task \"script\", ->\n    gulp.src [\"xxxx.js\", \"!xxx.min.js\"]\n    .pipe plumber()\n    .pipe jshint()\n    .pipe rename\n        extname: \".min.js\"\n    .pipe uglify\n        managle: no\n    .pipe rev()          # 加版本号\n    .pipe gulp.dest \"压缩文件\"\n    .pipe rev.manifest   # 这部分解决 js html 同时压缩时映射文件被覆盖问题\n        path    : path.join __dirname, \"映射文件目录/#{appName}/rev-manifest.json\"\n        cwd     : path.join __dirname, \"映射文件目录\"\n        merge   : yes\n    .pipe gulp.dest \"版本文件输出目录\"\n</code></pre>\n<h2> </h2>\n<h3>css 压缩合并</h3>\n<pre><code class=\"language-coffeescript\">gulp = require \"gulp\"\nrename = require \"gulp-rename\"\ncssImport = require \"gulp-cssimport\"\ncssmin = require \"gulp-cssmin\"\n\ngulp.task \"css\", ->\n    gulp.src [\"xxx\", \"yyy\"]\n    .pipe rename\n        extname: \".min.css\"\n    .pipe cssImport()\n    .pipe cssmin\n        compatibility: \"ie7\"\n    .pipe gulp.dest \"输出目录\"\n</code></pre>\n<h2> </h2>\n<h3>html 压缩</h3>\n<pre><code class=\"language-coffeescript\">gulp = require \"gulp\"\nplumber = require \"gulp-plumber\"\nhtmlmin = require \"gulp-htmlmin\"\nrename = require \"gulp-rename\"\n\ngulp.task \"html\", ->\n    options =\n        removeComments                  : false     # 清除HTML注释\n        collapseWhitespace              : true      # 压缩HTML\n        collapseBooleanAttributes       : true      # 省略布尔属性的值 &#x3C;input checked=\"true\"/> ====> &#x3C;input />\n        removeEmptyAttributes           : true      # 删除所有空格作属性值 &#x3C;input id=\"\" /> ====> &#x3C;input />\n        removeScriptTypeAttributes      : true      # 删除&#x3C;script>的type=\"text/javascript\"\n        removeStyleLinkTypeAttributes   : true      # 删除&#x3C;style>和&#x3C;link>的type=\"text/css\"\n        minifyJS                        : true      # 压缩页面JS\n        minifyCSS                       : true      # 压缩页面CSS\n\n    gulp.src [\"xxx/**/*.html\", \"!xxx/**/*.min.html\"]\n    .pipe plumber()  # 出错不跳出\n    .pipe htmlmin options\n    .pipe rename\n        extname: \".min.html\"\n    .pipe gulp.dest \"输出目录\"\n</code></pre>\n<h2> </h2>\n<h3>html 压缩加版本号</h3>\n<pre><code class=\"language-coffeescript\">path = require \"path\"\ngulp = require \"gulp\"\nplumber = require \"gulp-plumber\"\nhtmlmin = require \"gulp-htmlmin\"\nrename = require \"gulp-rename\"\nrev = require \"gulp-rev\"\n\ngulp.task \"html\", ->\n    options =\n        removeComments                  : false     # 清除HTML注释\n        collapseWhitespace              : true      # 压缩HTML\n        collapseBooleanAttributes       : true      # 省略布尔属性的值 &#x3C;input checked=\"true\"/> ====> &#x3C;input />\n        removeEmptyAttributes           : true      # 删除所有空格作属性值 &#x3C;input id=\"\" /> ====> &#x3C;input />\n        removeScriptTypeAttributes      : true      # 删除&#x3C;script>的type=\"text/javascript\"\n        removeStyleLinkTypeAttributes   : true      # 删除&#x3C;style>和&#x3C;link>的type=\"text/css\"\n        minifyJS                        : true      # 压缩页面JS\n        minifyCSS                       : true      # 压缩页面CSS\n\n    gulp.src [\"xxx/**/*.html\", \"!xxx/**/*.min.html\"]\n    .pipe plumber()  # 出错不跳出\n    .pipe htmlmin options\n    .pipe rename\n        extname: \".min.html\"\n    .pipe rev()\n    .pipe gulp.dest \"压缩文件输出目录\"\n    .pipe rev.manifest\n        path    : path.join __dirname, \"映射文件输出目录/rev-manifest.json\"\n        cwd     : path.join __dirname, \"映射文件输出目录\"\n        merge   : yes\n    .pipe gulp.dest \"版本文件输出目录\"\n</code></pre>\n<blockquote>\n<p>基本上平时会用到的功能都覆盖到了，高级用法控制文件流的找时间再整理整理</p>\n</blockquote>\n<hr>","frontmatter":{"path":"/fnrdoaUSK7UChWUhYSpxHPqg","title":"Gulp常用脚本","date":"2016-01-26 14:20:38 +0800","comments":true,"author":"Sir0xb","tags":["coffee","gulp"]},"excerpt":"js 压缩合并   js 压缩不合并   js 压缩加版本号   css 压缩合并   html 压缩   html 压缩加版本号 基本上平时会用到的功能都覆盖到了，高级用法控制文件流的找时间再整理整理"}}],"pathPrefix":"/","first":false,"last":true,"index":12,"pageCount":12,"additionalContext":{}}}